'***********************************************************************************************************
'			TCP ECHO ON WI-FI INTERFACE
'***********************************************************************************************************

include "global.tbh"

'THE GA1000 IS USED WITH THE EM1000
	Const WLN_RST=PL_IO_NUM_51
	Const WLN_CS=PL_IO_NUM_49
	Const WLN_DI=PL_IO_NUM_52
	Const WLN_DO=PL_IO_NUM_50
	Const WLN_CLK=PL_IO_NUM_53

const AP_NAME="Dog"						'<--------- set the name of your access point
const WEP_KEY="1239917010"							'<--------- WEP: leave empty to disable WEP, provide 10 HEX digits
														'for WEP-64, or 26 HEX digits for WEP-128
dim error as no_yes
'================================================================================================
dim judge as boolean
public dim fd_file_error as string
public dim message as string
public dim msgcnt as integer
public dim Run as boolean
public dim s as string

sub on_sys_init()
	dim x,y as byte
	dim task as pl_wln_tasks
	dim s as string
	fd_file_error=""
	message = ""
	msgcnt = 0
	Run = false
	
	error=NO	'this flag is for your convenience
	
	if WLN_RST=PL_IO_NULL or WLN_CS=PL_IO_NULL or WLN_DI=PL_IO_NULL or WLN_DO=PL_IO_NULL or WLN_CLK=PL_IO_NULL then
		sys.halt
		error=YES	'all interface lines must be properly mapped
	end if
	
		
	'----- allocate buffers -----
	sock.rxbuffrq(10)
	sock.txbuffrq(10)
	sock.varbuffrq(10)
	wln.buffrq(10)
	sys.buffalloc 


	'----- issue hardware reset -----
	
	io.num=WLN_RST
	io.enabled=YES	
	io.state=LOW
	io.state=HIGH
	

	'----- map interface lines -----
	
	wln.csmap=WLN_CS
	io.num=WLN_CS
	io.enabled=YES
	
	wln.dimap=WLN_DI
	
	wln.domap=WLN_DO
	io.num=WLN_DO
	io.enabled=YES
	
	wln.clkmap=WLN_CLK
	io.num=WLN_CLK
	io.enabled=YES
	

	'----- setup the socket -----
	
	sock.num=0
	sock.protocol=PL_SOCK_PROTOCOL_TCP
	sock.inconmode=PL_SOCK_INCONMODE_ANY_IP_ANY_PORT
	sock.reconmode=PL_SOCK_RECONMODE_0
	sock.localportlist="1001"
	sock.httpportlist="80"
	sock.httpmode=YES
	sock.allowedinterfaces="WLN"


	'----- setup the Wi-Fi interface -----
	
	wln.ip="192.168.0.105"			'<--------- select an IP address which is compatible with your network
	wln.gatewayip="192.168.0.1"		'<--------- this too
	wln.netmask="255.255.255.0"		'<--------- and this
	wln.domain=PL_WLN_DOMAIN_FCC	'<--------- comply with regulations (see "Selecting Domain")

	'----- boot up the GA1000 -----
	
	romfile.open("ga1000fw.bin")
	if wln.boot(romfile.offset)<>OK then
		sys.halt
		error=YES	'boot failed, check hardware and interface line mapping
	end if

	'----- set WEP -----
	
	select case len(WEP_KEY)
	case 0:
		'WEP disabled
	
	case 10:
		x=wln.setwep(WEP_KEY,PL_WLN_WEP_MODE_64)
		goto a1
	
	case 26:
		x=wln.setwep(WEP_KEY,PL_WLN_WEP_MODE_128)
a1:		if x<>OK then
			sys.halt
			error=YES	'something is wrong, this should not fail
		end if
		while wln.task<>PL_WLN_TASK_IDLE
		wend
	
	case else:
		sys.halt
		error=YES	'your WEP key is invalid
	end select

	
	'---- scan for access point -----
	
	if wln.scan(AP_NAME)<>OK then
		sys.halt
		error=YES	'something is wrong, this should not fail
	end if
	while wln.task<>PL_WLN_TASK_IDLE
	wend
	if wln.scanresultssid<>AP_NAME then
		sys.halt
		error=YES	'access point was not found
	end if


	'----- associate -----
	
	if wln.associate(wln.scanresultbssid,wln.scanresultssid,wln.scanresultchannel,wln.scanresultbssmode)<>OK then
		sys.halt
		error=YES	'something is wrong, this should not fail
	end if
	while wln.task<>PL_WLN_TASK_IDLE
	wend
	if wln.associationstate<>PL_WLN_ASSOCIATED then
		sys.halt
		error=YES	'association failed -- perhaps, your WEP mode is wrong?
	end if
	
	sock.num = 0
	sock.httpportlist = "80"
	sock.protocol = PL_SOCK_PROTOCOL_TCP
	sock.inconmode = PL_SOCK_INCONMODE_ANY_IP_ANY_PORT
	sock.reconmode =PL_SOCK_RECONMODE_0
	sock.txbuffrq(1)
	sock.varbuffrq(1)
	sock.rxbuffrq(1)
	sys.buffalloc
	
	If fd.format((fd.availableflashspace),1)<>PL_FD_STATUS_OK Then
      fd_file_error="some problem for format"
    End If
	
    select case fd.mount
		case PL_FD_STATUS_OK
	      fd_file_error=""
	    case PL_FD_STATUS_FAIL 
	      fd_file_error="Physical flash memory failure (fatal)"
	    case PL_FD_STATUS_CHECKSUM_ERR
	      fd_file_error="Checksum error has been detected in one of the disk sectors (fatal)"
	    case PL_FD_STATUS_FORMAT_ERR
	      fd_file_error="Disk formatting error has been detected (fatal)"
	end select
	   	   
	select case fd.create("myflashfile.txt")
	case PL_FD_STATUS_OK
	   fd_file_error=""
	case PL_FD_STATUS_FAIL
	   fd_file_error="PL_FD_STATUS_FAIL"
	case PL_FD_STATUS_CHECKSUM_ERR
	   fd_file_error="PL_FD_STATUS_CHECKSUM_ERR"	
	case PL_FD_STATUS_INV_PARAM
	   fd_file_error="PL_FD_STATUS_INV_PARAM"	
	case PL_FD_STATUS_DUPLICATE_NAME
	   fd_file_error="PL_FD_STATUS_DUPLICATE_NAME"
	case PL_FD_STATUS_FILE_TABLE_FULL
	   fd_file_error="PL_FD_STATUS_FILE_TABLE_FULL"
	case PL_FD_STATUS_DATA_FULL
	   fd_file_error="PL_FD_STATUS_DATA_FULL"	   
	case PL_FD_STATUS_NOT_READY
	   fd_file_error="PL_FD_STATUS_NOT_READY"	   	   
    end select		
	
	' Serial Port RS232
  	ser.num = 0
	ser.baudrate = ser.div9600/12
	ser.interface = PL_SER_SI_HALFDUPLEX
	ser.interchardelay = 50
	ser.parity = PL_SER_PR_NONE
	ser.rxbuffrq(10)
	ser.txbuffrq(10)
	sys.buffalloc
	ser.enabled = YES
	
	ser.num = 3
	ser.baudrate = ser.div9600/12
	ser.interface = PL_SER_SI_HALFDUPLEX
	ser.interchardelay = 50
	ser.parity = PL_SER_PR_NONE
	ser.rxbuffrq(10)
	ser.txbuffrq(10)
	sys.buffalloc
	ser.enabled = YES
	
	judge = false
	
	Control(IO_1, false)
	Control(IO_2, false)
	Control(IO_3, false)
	Control(IO_4, false)
	Control(IO_5, false)
	Control(IO_6, false)
	
end sub


'================================================================================================
sub on_wln_event(wln_event as pl_wln_events)
	dim x as byte

	sys.halt
	x=wln_event	'something happened
end sub


'================================================================================================
sub on_sock_data_arrival()
	sock.setdata(sock.getdata(sock.txfree))
	sock.send

end sub

'================================================================================================
sub on_sock_event(newstate as pl_sock_state, newstatesimple as pl_sock_state_simple)
	if newstatesimple=PL_SSTS_EST then
		pat.play("G~",PL_PAT_CANINT)
	else
		pat.play("-",PL_PAT_CANINT)
	end if
end sub

'

sub on_button_pressed
	judge = true
end sub
sub Alert()
	if(judge) then
		sock.setdata(true)
	else
		sock.setdata(false)
	end if
	judge = false
	sock.send
end sub
'Control the LED is on or off
sub Control(byref output as pl_io_num, checked as boolean)
	io.num = output
	io.enabled = YES
	if checked = false then
		io.state = HIGH
	else
		io.state = LOW
	end if
end sub
'Checkbox is checked or unchecked
sub State(byref output as pl_io_num)
	io.num = output
	io.enabled = YES
	if io.state = LOW then
		sock.setdata(true)
	else 
		sock.setdata(false)
	end if
	sock.send
end sub
'Show state is on or off
sub Show(byref output as pl_io_num)
	io.num = output
	io.enabled = YES
	if io.state = LOW then
		sock.setdata("ON")
	else 
		sock.setdata("OFF")
	end if
	sock.send
end sub
'Get Message
sub GetMessage()
	dim j as integer
	if fd_file_error="" then   '開啟與建立flash disk file?
		s="" 
		fd.filenum=3   '檔案代碼 
		fd.open("myflashfile.txt")
		'for j=1 to fd.filesize
			fd.setpointer(0)
			s= s+fd.getdata(4000)
		'next
		fd.close
	end if
end sub
'Save Message
sub SaveMessage(msg as string)
	if fd_file_error="" then   '開啟與建立flash disk file
		fd.filenum=3   '檔案代碼
		fd.open("myflashfile.txt")
		fd.setpointer(fd.filesize+1) 'works always -- no matter whether the file is empty or not
		fd.setdata("Message " + str(msgcnt+1) + ": " + msg +"<br>")  '寫入timercount
		fd.close
	else    '開啟與建立flash disk file有錯誤
		s="開啟與建立flash disk file有錯誤"
	end if
end sub

sub JudgeMessage(msg as string)
	if msg = "Earthquake"  or  msg = "earthquake" or msg = "地震" then
		Control(IO_1, true)
		'Control(IO_3, false)
	end if
end sub

'sensor_data
public dim rx_data as string 
public dim temp_string as string
public dim prx_data as string
public dim temperature as string
public dim humidity as string
public dim co as string
sub on_ser_data_arrival()
' TODO: place "on_ser_data_arrival" event handler code here...
dim str1 as string
dim str2 as string
dim temp as string
	rx_data = ""
	while ser.rxlen > 0 
		rx_data = rx_data + ser.getdata(255)
	wend
	if ser.num = 0 then
		str1 = mid(rx_data,4,6)
		str2 = mid(rx_data,14,5)
		temp = mid(str1,1,1)
		if temp > "2" then
			Control(IO_3, true)
		else
			Control(IO_3, false)
		end if
		temperature = "Temperature: " + str1
		humidity = "Humidity: " + str2
		temp_string = left(rx_data,11)
		if temp_string = "Temperature" then
			prx_data = "No Device"
		else
			pat.play("B",PL_PAT_CANINT)
			prx_data = rx_data
			rx_data ="No Device"
		end if
	else if ser.num = 3 then
		str1 = mid(rx_data,4,6)
		str2 = mid(rx_data,13,5)
		co = "S "+str1+"T "+str2+"\n"
	end if
	ser.rxclear
	ser.txclear
end sub

'show sensor_data
sub sock_setsend(byref s as string)
'Making sure the tx buffer is free before adding more data to the buffer.
	while sock.txfree<len(s)
		if sock.num=0 then
			if sock.statesimple = PL_SSTS_CLOSED then		
				sock.txclear
				exit sub
			end if
		end if
	wend
	sock.setdata(s)
	sock.send
	sock.rxclear
end sub